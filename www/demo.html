<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>OpenEth</title>
	<meta name="description" content="Community-driven ethical explication system.">
	<meta name="author" content="Remco Bloemen">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<!-- Try to load fonts from Google (but we have them local if the CDN fails) -->
	<link href='https://fonts.googleapis.com/icon?family=Material+Icons' rel='stylesheet'>
	<link href='https://fonts.googleapis.com/css?family=Roboto:400,700,400italic,300,300italic' rel='stylesheet'>
	<link type="text/css" href="/dex.css" rel='stylesheet'>
</head>
<body>
<header>
<nav>
	<div class="nav-wrapper">
		<a href="#" class="brand-logo center">OpenEth</a>
	</div>
</nav>
</header>
<button id="btn-login" disabled/>Login</button>

<main id="main">

<div class="row">
	<div class="col s4">
		<h2>Examples</h2>
		<ul>
			<li onclick="load('examples/medical_reminding.json')">Medical Reminding</li>
			<li onclick="load('examples/assisted_driving.json')">Assisted Driving</li>
			<li onclick="load('examples/medical_treatment.json')">Medical Treatment</li>
			<li onclick="load('examples/rescue.json')">Rescue</li>
		</ul>
	</div>
	<div class="col s8">
		<h2>Guidance</h2>
		<div class="speechbubble">
			<div style="float: left;">
				<img id="buddha" src="buddha.png">
				<div id="buddha_shadow"></div>
			</div>
			<div id="guidance"></div>
			<div style="clear: both;"></div>
		</div>
	</div>
</div>

<dilemma data-editor="edit_dilemma">
	<h1>Dilemma:
		<span data-content="name"></span>
		<button onclick="editm(parentNode.parentNode)">Edit</button>
		<button onclick="debug()">Debug</button>
		<button onclick="test()">Test</button>
	</h1>
	<p data-content="description"></p>
	<div class="row">
		<div class="col s6">
			<h6>Possible actions</h6>
			<ul id="actions"
				data-array="actions"
				data-onreorder="actions.reorder">
				<li
					hidden
					data-content
					onclick="actions.edit(this)"
					>
				</li>
			</ul>
		</div>
		<div class="col s6">
			<h6>
				Features
				<button onclick="features.add()">Add</button>
			</h6>
			<ul id="features"
				data-array="features"
				data-onreorder="features.reorder">
				<li
					hidden
					data-content
					onclick="features.edit(this)"
					>
				</li>
			</ul>
		</div>
	</div>
</dilemma>

<div class="row">
	<div class="col s6">
		<h2>Prima facie duties</h2>
		<div id="duties">
		</div>
	</div>
	<div class="col s6">
		<h2>Principles</h2>
		<div id="principles">
		</div>
	</div>
</div>

<h2>
	Cases
	<button onclick="cases.add()">Add</button>
</h2>
<cases id="cases" data-array="cases" data-onreorder>
	<case hidden onclick="cases.edit(this)">
		<h4>Case: <span data-content="name"></span></h4>
		<p data-content="description"></p>
		<p>Correct action: <em
			class="action"
			data-join="this.textContent=actions.name(data.action)"
			data-extract="return {action: actions.index(this.textContent)}"
			></em></p>
		<div hidden
			data-join="this.textContent=JSON.stringify(data.features)"
			data-extract="return {features:JSON.parse(this.textContent)}">[]</div>
	</case>
</cases>

</main>

<!-- Dialogues -->

<form id="guidance_case" hidden>
	<div class="content">
		<h4>Guidance</h4>
		<p>Is it possible to have a case where <b data-template="action"></b> is the correct action?</p>
	</div>
	<footer>
		<button type="submit">Yes</button>
		<button type="reset">No</button>
	</footer>
</form>

<form id="guidance_duty" hidden>
	<div class="content">
		<h4>Guidance</h4>
		<p>Can one infer that there is (at least) a (prima facie) duty to minimize <span data-template="feature"></span>?</p>
	</div>
	<footer>
		<button type="submit">Yes</button>
		<button type="reset">No</button>
	</footer>
</form>

<form id="guidance_duty_infered" hidden>
	<div class="content">
		<h4>Guidance</h4>
		<p>Therefore, it can be inferred that there is (at least) a (prima facie) duty to maximize <span data-template="feature"></span>.</p>
	</div>
	<footer>
		<button type="submit">Ok</button>
	</footer>
</form>

<form id="inconsistency" hidden>
	<div class="content">
		<h4>Internal Inconsistency</h4>
		<p>Another ethically relevant feature is needed in this case to resolve in internal inconsistency.</p>
	</div>
	<footer>
		<button type="submit">Ok</button>
	</footer>
</form>

<!-- Edit forms -->

<form id="debug" hidden>
	<div class="contents">
		<h4>Debug</h4>
		<label>JSON export
			<textarea data-join="this.value=JSON.stringify(data)"></textarea>
		</label>
	</div>
	<footer>
		<button type="submit">Ok</button>
	</footer>
</form>

<form id="edit_action" hidden>
	<div class="contents">
		<h4>Edit Action</h4>
		<p>An action is a.</p>
		<label>Name of action
			<input type="text" data-value>
		</label>
	</div>
	<footer>
		<button type="submit">Ok</button>
		<button type="reset">Cancel</button>
	</footer>
</form>

<form id="edit_feature" hidden>
	<div class="contents">
		<h4>Edit Feature</h4>
		<p>An feature is a.</p>
		<label>Name of feature
			<input type="text" data-value>
		</label>
	</div>
	<footer>
		<button type="submit">Ok</button>
		<button type="reset">Cancel</button>
		<button type="submit" value="remove">Remove</button>
	</footer>
</form>

<form id="edit_dilemma" hidden>
	<div class="contents">
		<h4>Edit Dilemma</h4>
		<p>A dilemma is a problem offering two possibilities, neither of which is unambiguously acceptable or preferable. One in this position has been traditionally described as "being on the horns of a dilemma", neither horn being comfortable. This is sometimes more colorfully described as "Finding oneself impaled upon the horns of a dilemma", referring to the sharp points of a bull's horns, equally uncomfortable (and dangerous).</p>
		<label>Name of dilemma
			<input type="text" data-value="name">
		</label>
		<label>Description of dilemma
			<textarea data-value="description"></textarea>
		</label>
	</div>
	<footer>
		<button type="submit">Ok</button>
		<button type="reset">Cancel</button>
	</footer>
</form>

<form id="edit_case" hidden>
	<div class="contents">
		<h4>Edit Case</h4>
		<p>A case study is a "published report about a person, group, or situation that has been studied over time." If the case study is about a group, it describes the behavior of the group as a whole, not behavior of each individual in the group. Case studies can be produced by following a formal research method. These case studies are likely to appear in formal research venues, as journals and professional conferences, rather than popular works. The resulting body of 'case study research' has long had a prominent place in many disciplines and professions, ranging from psychology, anthropology, sociology, and political science to education, clinical science, social work, and administrative science.</p>
		<label>
			Case name
			<input type="text" data-value="name">
		</label>
		<label>
			Case description
			<textarea data-value="description"></textarea>
		</label>
		<fieldset class="radio">
			<legend>Correct action</legend>
			<label>
				<input type="radio" name="action"
					data-join="this.checked=data.action==0"
					data-extract="return this.checked?{action:0}:{}"/>
				<span data-join="this.textContent=actions.name(0)"></span>
			</label>
			<label>
				<input type="radio" name="action"
					data-join="this.checked=data.action==1"
					data-extract="return this.checked?{action:1}:{}"/>
				<span data-join="this.textContent=actions.name(1)"></span>
			</label>
		</fieldset>
		
		<h5>Features</h5>
		<div id="case_features"
			data-join="cases.join_features(data)"
			data-extract="return cases.extract_features()">
			<fieldset hidden>
				<legend></legend>
				<div>
					<label hidden>
						<input type="checkbox" onchange="cases.change_checkbox(this)">
						<span></span>
						<span style="float: right;">0</span>
						<input type="range" min="-5" max="5" oninput="cases.change_range(this)">
					</label>
				</div>
			</fieldset>
		</div>
		
		<h5>Effective features</h5>
		<table id="cases_table" data-join="cases.update_table(data)">
			<thead></thead>
			<tbody></tbody>
		</table>
		
	</div>
	<footer>
		<button type="submit">Ok</button>
		<button type="reset">Cancel</button>
		<button type="submit" value="remove">Remove</button>
	</footer>
</form>

<footer class="page-footer">
	<div class="footer-copyright">
		<div class="container">
			© 2014—2016 The Dex Ethics Team.
		</div>
	</div>
</footer>
<script type="text/javascript" src='/dex.js'></script>
<script>
'use strict';

function make_unique(existing, name) {
	
	// If name doesn't exist, we are done
	if(!existing.includes(name)) {
		return name;
	}
	
	// Remove the " (n)" suffix from name
	name = name.replace(/ \(\d+\)$/, '');
	
	// Find the highest " (n)" suffix
	let n = 0;
	let r = new RegExp("^" + RegExp.escape(name) + " \\((\\d+)\\)$");
	for(let s of existing) {
		let matches = s.match(r);
		if(matches !== null) {
			n = Math.max(n, matches[1]);
		}
	}
	
	// Append " (n+1)"
	name = name + " (" + (n + 1) + ")";
	
	// Toast notify
	// Materialize.toast("Renamed to <em>" + HTMLEscape(name) +"</em>.", 4000);
	console.log("Renamed to <em>" + HTMLEscape(name) +"</em>.");
	return name;
}

let actions = document.getElementById('actions');
let cases = document.getElementById('cases');
let features = document.getElementById('features');
let guidance = document.getElementById('guidance');
let duties = document.getElementById('duties');
let principles = document.getElementById('principles');

actions.form = document.getElementById('edit_action');

actions.name = function(index) {
	return extract(actions).actions[index];
}

actions.index = function(name) {
	return extract(actions).actions.indexOf(name);
}

actions.edit = function(node) {
	let original = extract(node);
	let original_index = actions.index(original);
	let original_actions = extract(actions).actions;
	let others = original_actions.slice();
	others.splice(original_index, 1);
	
	join(actions.form, original);
	show_modal(actions.form, function() {
		let edited = extract(actions.form);
		
		// Trim leading/trailing white space
		edited = edited.trim();
		
		// The empty string is not allowed
		if(edited === "") {
			console.log("Action name can not be empty.", 4000);
			return;
		}
		
		// No-op fast path
		if(edited === original) {
			return;
		}
		
		// If the name is not unique, append a " (n)"
		edited = make_unique(others, edited);
		
		// Commit
		join(node, edited);
		
		// Update in the cases
		// TODO Empty strings also match the array template
		for(let e of cases.querySelectorAll('.action')) {
			if(e.textContent === original) {
				e.textContent = edited;
			}
		}
		
		// Update the principles
		principles.update();
	});
}

actions.reorder = function(old_index, new_index) {
	// This event handler is triggered by dragging the items in the list.
	// The list itself is already updated. But we still need to update
	// the matrices.
	old_index -= 1;
	new_index -= 1;
	for(let e of cases.getElementsByTagName('case')) {
		if(e.hasAttribute('hidden')) {
			continue;
		}
		let div = e.getElementsByTagName('div')[0];
		let matrix = extract(div);
		matrix.features.reorder(old_index, new_index);
		join(div, matrix);
	}
	
	// Update the principles
	principles.update();
}

features.form = document.getElementById('edit_feature');

features.name = function (index) {
	return extract(features).features[index];
}
features.index = function (name) {
	return extract(features).features.indexOf(name);
}

features.edit = function (node) {
	let original = extract(node);
	let original_index = features.index(original);
	let original_features = extract(features).features;
	let others = original_features.slice();
	others.splice(original_index, 1);
	
	join(features.form, extract(node));
	show_modal(features.form, function(action) {
		
		// User clicked [remove]
		if(action === "remove") {
			return features.remove(node);
		}
		
		// Extract the result
		let edited = extract(features.form);
		
		// Trim leading/trailing white space
		edited = edited.trim();
		
		// The empty string is not allowed
		if(edited === "") {
			Materialize.toast("Feature name can not be empty.", 4000);
			return;
		}
		
		// No-op fast path
		if(edited === original) {
			return;
		}
		
		// If the name is not unique, append a " (n)"
		edited = make_unique(others, edited);
		
		// Commit
		join(node, edited);
		
		// Update the principles
		principles.update();
	});
}

features.add = function () {
	let others = extract(features).features;
	
	join(features.form, "");
	
	// TODO: Set the form to a 'new feature' mode.
	//       This should remove the [remove] button
	//       and probably change [ok] to [add].
	show_modal(features.form, function(action) {
		
		
		// Extract the result
		let edited = extract(features.form);
		
		// Trim leading/trailing white space
		edited = edited.trim();
		
		// The empty string is not allowed
		if(edited === "") {
			Materialize.toast("Feature name can not be empty.", 4000);
			return;
		}
		
		// If the name is not unique, append a " (n)"
		edited = make_unique(others, edited);
		
		// Commit
		let inst = features.children[0].cloneNode(true);
		inst.removeAttribute('hidden');
		join(inst, edited);
		features.appendChild(inst);
		
		// Update the case matrices
		for(let e of cases.getElementsByTagName('case')) {
			if(e.hasAttribute('hidden')) {
				continue;
			}
			let div = e.getElementsByTagName('div')[0];
			let matrix = extract(div);
			matrix.features.forEach(function (e){ e.insert(index, null); });
			join(div, matrix);
		}
		
		// Update the principles
		principles.update();
	});
}

features.remove = function(node) {
	let index = Array.prototype.indexOf.call(node.parentNode.children, node) - 1;
	node.parentNode.removeChild(node);
	
	// Update the case matrices
	for(let e of cases.getElementsByTagName('case')) {
		if(e.hasAttribute('hidden')) {
			continue;
		}
		let div = e.getElementsByTagName('div')[0];
		let matrix = extract(div);
		matrix.features.forEach(function (e){ e.remove(index); });
		join(div, matrix);
	}
	
	// Update the principles
	principles.update();
}

features.reorder = function(old_index, new_index) {
	// This event handler is triggered by dragging the items in the list.
	// The list itself is already updated. But we still need to update
	// the matrices.
	old_index -= 1;
	new_index -= 1;
	for(let e of cases.getElementsByTagName('case')) {
		if(e.hasAttribute('hidden')) {
			continue;
		}
		let div = e.getElementsByTagName('div')[0];
		let matrix = extract(div);
		matrix.features.forEach(function (e){ e.reorder(old_index, new_index); });
		join(div, matrix);
	}
	
	// Update the principles
	principles.update();
}

cases.form = document.getElementById('edit_case');

cases.edit = function(node) {
	let data = extract(node);
	
	join(cases.form, data);
	show_fullscreen(cases.form, function(action) {
		if(action === 'remove') {
			return cases.remove(node);
		}
		
		// TODO name treatment
		
		let data = extract(cases.form);
		join(node, data);
		
		// Update the principles
		principles.update();
	});
}

cases.add = function() {
	let existing = extract(cases).cases.map(function (o){ return o.name; });
	let a = extract(actions).actions;
	let f = extract(features).features;
	
	join(cases.form, {
		name: "New Case",
		description: "",
		action: undefined,
		features: [[null].repeat(f.length)].repeat(a.length)
	});
	
	show_fullscreen(cases.form, function(action) {
		
		// Extract the result
		let edited = extract(cases.form);
		console.log(edited);
		
		// Trim leading/trailing white space
		edited.name = edited.name.trim();
		
		// The empty string is not allowed
		if(edited.name === "") {
			edited.name = "New Case";
		}
		
		// If the name is not unique, append a " (n)"
		edited.name = make_unique(existing, edited.name);
		
		// Commit
		let inst = cases.children[0].cloneNode(true);
		inst.removeAttribute('hidden');
		join(inst, edited);
		cases.appendChild(inst);
		
		// Update the principles
		principles.update();
	});
}

cases.remove = function(node) {
	node.parentNode.removeChild(node);
	
	// Update the principles
	principles.update();
}

cases.join_features = function(data) {
	let a = extract(actions).actions;
	let f = extract(features).features;
	let root = document.getElementById('case_features');
	
	rescale_array(root, a.length);
	for(var i = 0; i < a.length; ++i) {
		let e = root.children[i + 1];
		let legend = e.getElementsByTagName('legend')[0];
		let div = e.getElementsByTagName('div')[0];
		legend.textContent = a[i];
		rescale_array(div, f.length);
		for(var j = 0; j < f.length; ++j) {
			let k = div.children[j + 1];
			let d = data.features[i][j];
			let checkbox = k.children[0];
			let label = k.children[1];
			let number = k.children[2];
			let range = k.children[3];
			label.textContent = f[j];
			if(d === null) {
				checkbox.checked = false;
				range.value = 0;
				range.disabled = true;
				number.textContent = "";
			} else {
				checkbox.checked = true;
				range.value = d;
				range.disabled = false;
				number.textContent = d;
			}
		}
	}
}

cases.extract_features = function() {
	let root = document.getElementById('case_features');
	
	let r = [];
	for(var i = 1; i < root.children.length; ++i) {
		let e = root.children[i];
		let rr = [];
		let div = e.getElementsByTagName('div')[0];
		for(var j = 1; j < div.children.length; ++j) {
			let k = div.children[j];
			let checkbox = k.children[0];
			let range = k.children[3];
			if(checkbox.checked) {
				rr.push(parseInt(range.value));
			} else {
				rr.push(null);
			}
		}
		r.push(rr);
	}
	return {features: r};
}


cases.change_checkbox = function(node) {
	let label = node.parentNode;
	let checkbox = label.children[0];
	let span = label.children[1];
	let number = label.children[2];
	let range = label.children[3];
	
	if(checkbox.checked) {
		number.textContent = range.value;
		range.disabled = false;
	} else {
		number.textContent = "";
		range.disabled = true;
	}
	
	cases.update_table(extract(cases.form));
}

cases.change_range = function(node) {
	let label = node.parentNode;
	let checkbox = label.children[0];
	let span = label.children[1];
	let number = label.children[2];
	let range = label.children[3];
	
	number.textContent = range.value;
	
	cases.update_table(extract(cases.form));
}

function flesh_out(table) {
	let rows = table.length;
	if(rows === 0)
		return table;
	let cols = table[0].length;
	if(cols === 0)
		return table;
	for(let i = 0; i < rows; ++i) {
		for(let j = 0; j < cols; ++j) {
			if(table[i][j] === null) {
				table[i][j] = -table[rows - i - 1][j];
			}
			if(table[i][j] === null) {
				table[i][j] = 0;
			}
		}
	}
	return table;
}

cases.update_table = function(data) {
	data = flesh_out(data.features);
	let inputs = document.getElementById('case_features');
	let table = document.getElementById('cases_table');
	let thead = table.getElementsByTagName('thead')[0];
	let tbody = table.getElementsByTagName('tbody')[0];
	
	let action_labels = extract(actions).actions;
	let feature_labels = extract(features).features;
	
	while(thead.hasChildNodes()) {
		thead.removeChild(thead.lastChild);
	}
	while(tbody.hasChildNodes()) {
		tbody.removeChild(tbody.lastChild);
	}
	
	let tr = document.createElement('tr');
	tr.appendChild(document.createElement('td'));
	for(let f of feature_labels) {
		let th = document.createElement('th');
		th.textContent = f;
		tr.appendChild(th);
	}
	thead.appendChild(tr);
	let i = 0;
	for(let a of action_labels) {
		let tr = document.createElement('tr');
		let th = document.createElement('th');
		th.textContent = a;
		tr.appendChild(th);
		let j = 0;
		for(let f of feature_labels) {
			let td = document.createElement('td');
			td.textContent = data[i][j];
			tr.appendChild(td);
			++j;
		}
		tbody.appendChild(tr);
		++i;
	}
}

Array.prototype.greaterOrEqualThan = function(other) {
	return this.every((e, i) => e >= other[i]);
}

Array.prototype.zip = function(other) {
	let result = [];
	for(let i = 0; i < this.length; ++i) {
		result.push([this[i], other[i]]);
	}
	return result;
}

function findSigns(positive, negative) {
	let n = positive[0].length;
	
	let possibleSigns = [];
	for(let i = 0; i < Math.pow(2, n); ++i) {
		
		// Create a signing
		let sign = [];
		for(let j = 0; j < n; ++j) {
			sign.push(((i & (1 << j)) != 0) ? -1 : 1);
		}
		
		// Apply the sign
		let pos = positive.map(e => e.map((e, i) => e * sign[i]));
		let neg = negative.map(e => e.map((e, i) => e * sign[i]));
		
		// Check the consistency
		// ∀ p ∊ pos ∀ n ∊ neg ∃ i nᵢ < pᵢ
		if(pos.every(p => neg.every(n => n.some((e, i) => e < p[i])))) {
			possibleSigns.push(sign);
		}
	}
	if(possibleSigns.length == 0) {
		console.log("Inconsistent signs!");
	}
	
	// The result is zero if there there is ambiguity
	let result = possibleSigns[0];
	for(let signs of possibleSigns) {
		for(let i = 0; i < n; ++i) {
			if(result[i] !== signs[i]) {
				result[i] = 0;
			}
		}
	}
	return result;
}

// Maximize the volume {x | x ≥ clause} s.t. forbidden ∩ volume = ∅
function maximizeVolume(clause, forbidden)
{
	// Check consistency
	// ∀ n ∊ forbidden ∃ i nᵢ < clauseᵢ
	if(!forbidden.every(n => n.some((e, i) => e < clause[i]))) {
		console.log("Inconsistent clause!");
		return undefined;
	}
	
	// For every permutation of the dimensions
	let options = Array.range(clause.length).permutations().map(order => 
		// Maximize the volume greedy one dimension at a time
		order.reduce(function (option, dimension) {
			// Set the dimension to the minimal dimension of
			// the forbidden vectors that would fall inside the volume
			let bound = Math.max.apply(null,
				forbidden.filter(e =>
					e.every((x, i) => i === dimension || x >= option[i])
				).map(e => 1 + e[dimension]));
			if(bound > option[dimension]) {
				console.log("Illegal bound in maximizeVolume");
			}
			option[dimension] = bound;
			return option;
		}, clause.clone())
		
	// Unique the solutions
	).filter((e,i,a) => i == a.findIndex(f => f.every((g, j) => g == e[j])));
	
	// Prefer solutions with the least number of variables
	let variables = Math.min.apply(null, options.map(e => e.length - e.filter(f => f === -Infinity).length));
	options = options.filter(e => e.length - e.filter(f => f === -Infinity).length == variables);
	return options;
}

principles.update = function() {
	let a = extract(actions).actions;
	let f = extract(features).features;
	let n = f.length;
	
	// Compute the positive and negative vectors
	let positive = [];
	let negative = [];
	let data = extract(cases);
	for(let c of data.cases) {
		let mat = flesh_out(c.features);
		
		let correct = c.action;
		let incorrect = 1 - c.action;
		
		// Δ = a₁ - a₂
		let delta = [];
		for(let i = 0; i < n; ++i) {
			delta[i] = mat[correct][i] - mat[incorrect][i];
		}
		// Positive: prefer(correct, incorrect) =  Δ
		// Negative: prefer(incorrect, correct) = -Δ
		positive.push(delta);
		negative.push(delta.map(e => -e));
	}
	
	// Find the signs, the prima facie duties
	let signs = findSigns(positive, negative);
	
	// Print the duties
	duties.innerHTML = "<ul><li>It can be inferred that there are (prima facie) duties to <ul>"
		+ signs.map((e, i) => e === 0 ? undefined : ((e < 0 ? "minimize " : "maximize ") + f[i]))
		.filter(e => e !== undefined).map(e => "<li>" + e + "</li>").join() + "</ul></li></ul>";
	
	// Give guidance on ambiguity
	guidance.innerHTML = signs.map((e,i) => e !== 0 ? "" :
		("<p>Could not determine if " + f[i] + " is a good or a bad thing.</p>")).join();
	
	// Apply signs
	positive = positive.map(e => e.map((e, i) => e * signs[i]));
	negative = negative.map(e => e.map((e, i) => e * signs[i]));
	
	// Find different maximal volumes of positive clauses
	let clauses = positive.map(e => maximizeVolume(e, negative));
	
	// If there are multiple solutions, find the simplest one
	function findSolutions(remaining) {
		if(remaining.length === 0) {
			return [[]];
		}
		let current = remaining[0];
		let recurse = findSolutions(remaining.slice(1));
		let result = [];
		for(let clause of current) {
			for(let r of recurse) {
				result.push([clause].concat(r));
			}
		}
		return result;
	}
	let solutions = findSolutions(clauses);
	
	// Minimize the solutions by removing duplicate clauses
	solutions = solutions.map(s => s.unique((a,b) => a.equals(b)));
	
	// Find the solutions with the smallest number of clauses
	let num_clauses = Math.min.apply(null, solutions.map(s => s.length));
	solutions = solutions.filter(s => s.length === num_clauses);
	if(solutions.length > 1) {
		console.log("Still some ambiguity remaining.");
	}
	let solution = solutions[0];
	
	// Print the clauses
	let principle = "<ul>";
	for(let clause of solution) {
		principle += "<li>An action is ethically preferable to another if it <ul>"
		let i = 0;
		for(let constraint of clause) {
			if(constraint === -Infinity) {
				++i;
				continue;
			}
			principle += "<li>";
			if(constraint > 0) {
				principle += "satisfies the duty to "
			} else {
				principle += "does not violate the duty to "
			}
			if(signs[i] < 0) {
				principle += "minimize "
			} else {
				principle += "maximize "
			}
			principle += f[i];
			principle += " by a value ";
			if(constraint > 0) {
				principle += "at least "
			} else {
				principle += "greater than "
			}
			principle += Math.abs(constraint)
			principle += " more"
			principle += "</li>";
			++i;
		}
		principle += "</ul></li>"
	}
	principles.innerHTML = principle;
}

function debug()
{
	let data = extract('main');
	let form = document.getElementById('debug');
	join(form, data);
	show_modal(form);
}

function test()
{
	let data1 = extract('main');
	join('main', data1);
	let data2 = extract('main');
	console.log(data1, data2);
	if(JSON.stringify(data1) !== JSON.stringify(data2)) {
		console.log("Test failed");
	}
}

function load(url) {
	get(url, function(data) {
		join('main', data);
		
		// Update the principles
		principles.update();
	});
}


window.addEventListener('DOMContentLoaded', function() {
	// Load an empty case
	join('main', {
		"name": "New Dilemma",
		"description": "Please edit this dilemma.",
		"actions": [
			"Action A",
			"Action B"
		],
		"features": ["Feature 1"],
		"cases": []
	});
});


</script>

</body>
</html>
